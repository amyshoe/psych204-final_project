//File created to draft the input processing algorithms for single-reference story problem solving.


//var to_procedure = function(problem){

}

//var story2procedure = function(problem, time_remaining){
    //if problem.num_refs == 1: green success
    // if problem.num_refs == 2: red success

//}

//var to_symbols = function(problem){
    

}

	// unwind
		// errors: PEMDAS mistakes
		// strat: look just at two numbers alone, performing op after op
	// guess and check
		// time penalties
	// symb manip
		// errors: PEMDAS mistakes, performing reverse ops to both sides of op instead of =
		// strat: rewrite the equation at each step

	//NOTE at several points in this algo, check if time <= 0, and return None if that's the case


var sym_manip = function (problem, time_remaining){

}

var unwind = function (problem, time_remaining){

}

var guess_check = function(problem, time_remaining){

}

var getAnswer = function(problem, strategy, time_remaining) {
	// DO ANY NECESSARY CONVERSIONS
	if (strategy == "u_w") {
		if (!problem.verbal) time_remaining = time_remaining - 1;
		return unwind(problem, time_remaining);
	} else if (strategy = "g_ch"){
		if (!problem.verbal) time_remaining = time_remaining - 1;
		return guess_check(problem, time_remaining);
	} else if (strategy = "s_m") {
		if (problem.verbal) time_remaining = time_remaining - 1; 
		return sym_manip(problem, time_remaining);
	}
}

var model = function() {

	// Data
	// ATTRIBUTES:
		// verbal: true (story) false (eq)
		// num_refs: 1/2
		// inputs:
		// operations: 
	var problem1 = {verbal: true, num_refs: 1, inputs: [7, -1, 5, 40], operations: ['*', '+', '=']}
	//var problem2 = {...}
	var observedData = [problem1]
	var trueAnswers = [5]
	var indices = [1] // range(observedData.length)
	//time_limit somewhere over here


	// Choose a strategy for each problem <-----------------------TODO: not sure if this will prevent updates to the prior
																	//  for specific problems. maybe need to not use repeat
																	//  and instead chooseStrategy for each problem?
																	//  (In which case, this set up is overkill?)
	var strategies = ['u_w', 'g_ch', 's_m']
	// prior for which strategy: unwind/untangle, guess n check, symbolic manip
	var stratToUse = function(problem){return T.toScalars(dirichlet(ones([strategies.length, 1])))}
	var chooseStrategies = function(problem){
  		var probs = stratToUse(problem);
  		return repeat(observedData.length, function(){return categorical({vs: strategies, ps: probs})});
	}

	// get answers, and condition on those answers being true
	var myAnswers = mapData({data: observedData, mapData({data: observedData}, chooseStrategies)}, getAnswer) // TODO: change this to 
																											  // recursion with a time
																											  // variable that gets --
	var obsFn = function(idx) {condition(myAnswers[idx]) == trueAnswers[idx]}
	mapData({data: indices}, obsFn)

	return myAnswers

}