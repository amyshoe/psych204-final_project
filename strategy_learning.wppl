// var eq2procedure = function(problem){
//     //blue success
// }

// var story2procedure = function(problem){
//     // if problem.num_refs == 1: green success
//     // if problem.num_refs == 2: red success
// }

var model = function() {

    // Data
    var problem1 = {verbal: true, inputs: ['x', 6, 66, 84], ops: ['per', 'and', 'total']}
    var problem2 = {verbal: false, inputs: ['x', 6, 66, 84], ops: ['*', '+', '=']}
    var problem3 = {verbal: true, inputs: ['x', 3, 64, 133], ops: ['each', 'and', 'is']}
    var problem4 = {verbal: false, inputs: ['x', 3, 64, 133], ops: ['*', '+', '=']}
    var observedData = [problem1, problem2, problem3, problem4]
    var trueAnswers = [3, 3, 23, 23]
    var indices = [0,1,2,3] // range(observedData.length)
    globalStore.time_elapsed = 0
    var increment_time = function(t){globalStore.time_elapsed = globalStore.time_elapsed + t}
    
    // var strategies = ['unwind', 'guess_check', 'sym_manip']
    var strategies = ['unwind', 'sym_manip']
    // prior for which strategy: unwind/untangle, guess n check, symbolic manip
    var stratToUse = function(){return T.toScalars(dirichlet(ones([strategies.length, 1])))}
    var chooseStrategies = function(){
        var probs = stratToUse();
        return repeat(observedData.length, function(){return categorical({vs: strategies, ps: probs})});
    }
    
    var story2eq = function(problem){
      // TODO : fix this, since mutating arrays is not allowed in webppl (even in globalStore)
      //            without hacky hardcode ways that don't allow for problem flexibility

      // problem.ops.slice(1+find(function(x){return (x == 'is') || (x == 'total');}, problem.ops)) = '='
      // problem.ops.slice(1+find(function(x){return (x == 'and');}, problem.ops)) = '+'
      // problem.inputs.slice(1+find(function(x){return (x == 'per') || (x == 'each');}, problem.ops)) = '*'
      var modified_problem = {verbal: true, inputs: problem.inputs, ops: ['*', '+', '=']}
      increment_time(1)
      return modified_problem
    }
    
    // MAIN PART OF THE MODEL
    var getAnswer = function(problem, strategy) {
        // DO ANY NECESSARY CONVERSIONS 
        // NOTE: I THINK ONLY STORY2EQ SHOULD BE HERE.
        // if (problem.verbal) { // story problem
        //  strategy == 'sym_manip' ? story2eq(problem) : story2procedure(problem)
        // }
        // else { // equation problem 
        //  if (strategy != 'sym_manip') {eq2procedure(problem)}
        // }
        if (problem.verbal && strategy == 'sym_manip') {var problem = story2eq(problem)}
        
        // SOLVE THE PROBLEM
        if (strategy == 'unwind') { ////////////////////////////// /// UNWIND ///
            // NOTE: THIS SECTION USED TO BE USING FIND() TO GET THE IDX OF OPS (VERBAL OR SYMBOL)
            //          BUT IT SEEMED TO NOT BEHAVE NICELY WITH SLICE(). SO NOW THIS ONLY WORKS
            //          FOR X*A+B=C EQUATIONS.
            // TODO: MAKE MORE GENERAL/FLEXIBLE
            if (problem.verbal) {
                if (flip(.7)) {
                    //do the correct reverse order op (first look for 'total/is' then 'and', then 'per/each')
                    globalStore.ans = Math.floor(problem.inputs.slice(-1)) // RHS of 'total/is'
                    // increment_time(1) 
                    globalStore.ans -= Math.floor(problem.inputs.slice(2,3)) // RHS of 'and'
                    globalStore.ans /= Math.floor(problem.inputs.slice(1,2)) // RHS of 'per/each'  
                    increment_time(1)
                } else { //PEMDAS error
                    globalStore.ans = Math.floor(problem.inputs.slice(-1))// RHS of 'total/is'
                    // increment_time(1)
                    globalStore.ans /= Math.floor(problem.inputs.slice(1,2))  // RHS of 'per/each'  
                    globalStore.ans -= Math.floor(problem.inputs.slice(2,3)) // RHS of 'and'  
                    increment_time(1)
                }
            } else { // eq problem
                if (flip(.6)) {
                    //do the correct reverse order op (first look for '=' then '+', then '*')
                    globalStore.ans = Math.floor(problem.inputs.slice(-1))// RHS of '='
                    // increment_time(1)
                    globalStore.ans -= Math.floor(problem.inputs.slice(2,3)) // RHS of '+'
                    globalStore.ans /= Math.floor(problem.inputs.slice(1,2))  // RHS of '*'  
                    increment_time(1)
                } else { //PEMDAS error
                    globalStore.ans = Math.floor(problem.inputs.slice(-1))// RHS of '='
                    // increment_time(1) 
                    globalStore.ans /= Math.floor(problem.inputs.slice(1,2))  // RHS of '*'  
                    globalStore.ans -= Math.floor(problem.inputs.slice(2,3)) // RHS of '+' 
                    increment_time(1)
                }
            }
            // increment_time(1)
            // only return answer if they didn't run out of time
            if (globalStore.time_elapsed < 30) {
                return globalStore.ans;
            } else {return null;}
            // (globalStore.time_elapsed < 30) ? (return globalStore.ans;) : (return null;)
        } 

        else if (strategy == 'guess_check') { /////////////////// /// GUESS AND CHECK ///
            // uniform draw 1:10
            // check if solution makes the equation balanced. <------------------- TODO: need a case of story vs eq
            // shift range 
            // add a time unit
            increment_time(1)
            // check time elapsed
            // eq not balanced and time allows, repeat. else, return ans
        } else { //////////////////////////////////////////////// /// SYMBOL MANIPULATION ///
            // TODO: make this all more flexible...now it only works for x*a+b=c format
            if (problem.inputs.length == 2) { // base case
                return Math.floor(problem.inputs.slice(-1))
            }
            if (flip(.8) || problem.ops.length < 3) { //correct PEMDAS and op balancing
                var new_inputs = problem.inputs.slice(0,-1)
                if ('+' in problem.ops) {
                    new_inputs.push(Math.floor(problem.inputs.slice(-1)) - Math.floor(problem.inputs.slice(-2,-1)))
                } else {
                    new_inputs.push(Math.floor(problem.inputs.slice(-1)) / Math.floor(problem.inputs.slice(-2,-1)))
                }
                // ('+' in problem.ops) ? new_inputs.push(Math.floor(problem.inputs.slice(-1)) - Math.floor(problem.inputs.slice(-2,-1)))
                                     // : new_inputs.push(Math.floor(problem.inputs.slice(-1)) / Math.floor(problem.inputs.slice(-2,-1)))
                var simplified_problem = {verbal: false, inputs: new_inputs, ops: problem.ops.slice(1)}/////// FFFFFIIIIIIIIXXXXXXXX
                increment_time(1)
                if (globalStore.time_elapsed < 30) { // if time allows, recurse!
                    return getAnswer(simplified_problem, 'sym_manip');
                } else {return null;}
            } else if (problem.ops.length > 2) { // PEMDAS error -- can only happen with multiple ops
                if(flip(0.8)) { // correct op balancing
                    var new_inputs = ['x']
                    new_inputs.push(problem.inputs.slice(2,3)) // ['x', b]
                    new_inputs.push(Math.floor(problem.inputs.slice(-1)) / Math.floor(problem.inputs.slice(1,2))) //['x', b, c/a]
                    var simplified_problem = {verbal: false, inputs: new_inputs, ops: ['+', '=']}
                    increment_time(1)
                    if (globalStore.time_elapsed < 30) { // if time allows, recurse!
                        return getAnswer(simplified_problem, 'sym_manip');
                    } else {return null;}
                } else { // error in op balancing
                    var new_inputs = ['x']
                    new_inputs.push(Math.floor(problem.inputs.slice(2,3)) / Math.floor(problem.inputs.slice(1,2))) //['x', b/a]
                    new_inputs.push(problem.inputs.slice(-1)) //['x', b/a, c]
                    var simplified_problem = {verbal: false, inputs: new_inputs, ops: ['+', '=']}
                    increment_time(1)
                    if (globalStore.time_elapsed < 30) { // if time allows, recurse!
                        return getAnswer(simplified_problem, 'sym_manip');
                    } else {return null;}
                }
            }
        }
    }

    // get answers, and condition on those answers being true
    var myStrategies = chooseStrategies()
    var myAnswers = map2(getAnswer, observedData, myStrategies)

    var obsFn = function(idx) {condition(myAnswers[idx] == trueAnswers[idx])}
    mapData({data: indices}, obsFn)

    return {answers: myAnswers, strategies: myStrategies}
}

var d = Infer({method: 'forward', samples: 100}, model)
// var d = Infer({method: 'rejection', samples: 1000}, model)
d