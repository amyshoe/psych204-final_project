var eq2procedure = function(problem){
    //blue success
}

var story2procedure = function(problem){
    // if problem.num_refs == 1: green success
    // if problem.num_refs == 2: red success
}

var story2eq = function(problem){
    // blue success
}
	

var model = function() {

	// Data
	// ATTRIBUTES:
		// verbal: true (story) false (eq)
		// num_refs: 1/2
		// inputs:
		// operations: 
	var problem1 = {verbal: true, inputs: [6, 'x', 66, 84], ops: ['per', 'and', 'total']}
	var problem2 = {verbal: false, inputs: ['x', 6, 66, 84], ops: ['*', '+', '=']}
	var problem3 = {verbal: true, inputs: [3, 'x', 64, 133], ops: ['each', 'and', 'is']}
	var problem4 = {verbal: false, inputs: [3, 'x', 64, 133], ops: ['*', '+', '=']}
	var observedData = [problem1, problem2, problem3, problem4]
	var trueAnswers = [3, 3, 23, 23]
	var indices = [0,1,2,3] // range(observedData.length)
	globalStore.time_elapsed = []

	// Choose a strategy for each problem <-----------------------TODO: not sure if this will prevent updates to the prior
																	//  for specific problems. maybe need to not use repeat
																	//  and instead chooseStrategy for each problem?
																	//  (In which case, this set up is overkill?)
	var strategies = ['unwind', 'guess_check', 'sym_manip']
	// prior for which strategy: unwind/untangle, guess n check, symbolic manip
	var stratToUse = function(problem){return T.toScalars(dirichlet(ones([strategies.length, 1])))}
	var chooseStrategies = function(problem){
  		var probs = stratToUse(problem);
  		return repeat(observedData.length, function(){return categorical({vs: strategies, ps: probs})});
	}

	// MAIN PART OF THE MODEL
	var getAnswer = function(problem, strategy) {
		// DO ANY NECESSARY CONVERSIONS 
		// NOTE: I THINK ONLY STORY2EQ SHOULD BE HERE.
		// if (problem.verbal) { // story problem
		// 	strategy == 'sym_manip' ? story2eq(problem) : story2procedure(problem)
		// }
		// else { // equation problem 
		// 	if (strategy != 'sym_manip') {eq2procedure(problem)}
		// }
		if (problem.verbal && strategy == 'sym_manip') {story2eq(problem)}
		
		// SOLVE THE PROBLEM
		if (strategy == 'unwind') { // unwind
			// errors: PEMDAS mistakes
			// strat: look just at two numbers alone, performing op after op
			if (problem.verbal) {
				//do the correct order op (first look for per/each)
				// do the op with inputs[idx] and inputs[idx+1]
				globalStore.time_elapsed.push(1)
				// check time elapsed
				// repeat
			}
			else { // eq problem
				// flip to get choose * or + first
				// do the op with inputs[idx] and inputs[idx+1]
				globalStore.time_elapsed.push(1)
				// check time elapsed
				// repeat
			}
			// return ans
		} else if (strategy == 'guess_check') { // guess and check
			// go through list of possible solutions (random selection w/o replacement)
			// check if solution makes the equation balanced. <------------------- TODO: need a case of story vs eq
			// add a time unit 
			globalStore.time_elapsed.push(1)
			// check time elapsed
			// eq not balanced and time allows, repeat. else, return ans
		} else { // symb manip
			// flip for * or +
			// flip for performing reverse ops to both sides of op vs =
			// rewrite equation
			globalStore.time_elapsed.push(1)
			// check if time allows
			// recursion
			// NOTE: base case............
		}
		//NOTE at several points in this algo, check if time >= 18, and return None if that's the case


	// get answers, and condition on those answers being true
	var myAnswers = map2(getAnswer, observedData, mapData({data: observedData}, chooseStrategies)})

	var obsFn = function(idx) {condition(myAnswers[idx]) == trueAnswers[idx]}
	mapData({data: indices}, obsFn)

	return myAnswers

}