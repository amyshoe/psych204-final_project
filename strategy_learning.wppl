var eq2procedure = function(problem){
    //blue success
}

var story2procedure = function(problem){
    // if problem.num_refs == 1: green success
    // if problem.num_refs == 2: red success
}

var story2eq = function(problem){
    // blue success
}

var getAnswer = function(problem, strategy) {
	// DO ANY NECESSARY CONVERSIONS

	// unwind
		// errors: PEMDAS mistakes
		// strat: look just at two numbers alone, performing op after op
	// guess and check
		// time penalties
	// symb manip
		// errors: PEMDAS mistakes, performing reverse ops to both sides of op instead of =
		// strat: rewrite the equation at each step

	//NOTE at several points in this algo, check if time <= 0, and return None if that's the case
}

var model = function() {

	// Data
	// ATTRIBUTES:
		// verbal: true (story) false (eq)
		// num_refs: 1/2
		// inputs:
		// operations: 
	var problem1 = {verbal: true, inputs: [6, 'x', 66, 84], ops: ['per', 'and', 'total']}
	var problem2 = {verbal: false, inputs: ['x', 6, 66, 84], ops: ['*', '+', '=']}
	var problem3 = {verbal: true, inputs: [3, 'x', 64, 133], ops: ['each', 'and', 'is']}
	var problem4 = {verbal: false, inputs: [3, 'x', 64, 133], ops: ['*', '+', '=']}
	var observedData = [problem1, problem2, problem3, problem4]
	var trueAnswers = [3, 3, 23, 23]
	var indices = [0,1,2,3] // range(observedData.length)

	// Choose a strategy for each problem <-----------------------TODO: not sure if this will prevent updates to the prior
																	//  for specific problems. maybe need to not use repeat
																	//  and instead chooseStrategy for each problem?
																	//  (In which case, this set up is overkill?)
	var strategies = ['unwind', 'guess_check', 'sym_manip']
	// prior for which strategy: unwind/untangle, guess n check, symbolic manip
	var stratToUse = function(problem){return T.toScalars(dirichlet(ones([strategies.length, 1])))}
	var chooseStrategies = function(problem){
  		var probs = stratToUse(problem);
  		return repeat(observedData.length, function(){return categorical({vs: strategies, ps: probs})});
	}

	// get answers, and condition on those answers being true
	var myAnswers = mapData({data: observedData, mapData({data: observedData}, chooseStrategies)}, getAnswer) // TODO: change this to 
																											  // recursion with a time
																											  // variable that gets --
	var obsFn = function(idx) {condition(myAnswers[idx]) == trueAnswers[idx]}
	mapData({data: indices}, obsFn)

	return myAnswers

}